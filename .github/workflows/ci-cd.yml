name: "üê∞ RabbitMQ Infrastructure - CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  SERVICE_NAME: rabbitmq-infrastructure

permissions:
  contents: read
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      id-token: write
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml jq

      - name: Validate Docker Compose
        run: |
          docker compose -f docker-compose.yml config -q
          echo "‚úÖ Docker Compose syntax is valid"

      - name: Security Validation - No Hardcoded Passwords
        run: |
          # Verificar se n√£o h√° hardcoded passwords
          if grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "external:"; then
            echo "‚ùå Found potential hardcoded passwords"
            exit 1
          else
            echo "‚úÖ No hardcoded passwords found"
          fi

      - name: üîé Validar OIDC Azure
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
          AZURE_KEYVAULT_ENDPOINT: ${{ secrets.AZURE_KEYVAULT_ENDPOINT }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf '‚ùå GitHub Secrets obrigat√≥rios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "‚úÖ Identificadores Azure configurados via secrets"

          # Key Vault √© opcional
          if [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_keyvault=false" >> "$GITHUB_OUTPUT"
          fi

          if [[ -z "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            echo '‚ÑπÔ∏è AZURE_KEYVAULT_ENDPOINT n√£o definido (usando endpoint padr√£o)'
          else
            echo '‚úÖ Endpoint customizado definido'
          fi

          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"

      - name: Validate YAML files
        run: |
          python3 -c "
          import yaml
          import pathlib

          # Validar arquivos YAML principais
          yaml_files = [
              'docker-compose.yml'
          ]

          for file_path in yaml_files:
              if pathlib.Path(file_path).exists():
                  try:
                      with open(file_path, 'r', encoding='utf-8') as f:
                          yaml.safe_load(f)
                      print(f'‚úÖ YAML v√°lido: {file_path}')
                  except Exception as e:
                      print(f'‚ùå Erro no YAML {file_path}: {e}')
                      exit(1)
          "

      - name: ‚úÖ Confirmar consumo m√≠nimo do Key Vault
        if: ${{ steps.check_secrets.outputs.has_keyvault == 'true' }}
        run: |
          echo 'Job de valida√ß√£o n√£o consome segredos do Key Vault (lista vazia).'
          echo "‚úÖ Valida√ß√£o de Key Vault conclu√≠da sem consumo de segredos"

      - name: Validation completed
        run: |
          echo "‚úÖ Valida√ß√£o conclu√≠da - pronto para deploy"


  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [self-hosted, Linux, X64, conexao, conexao-de-sorte-rabbitmq-infraestrutura]
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1


      - name: üîê Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Key Vault secrets (RabbitMQ)
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        run: |
          # Usar endpoint se dispon√≠vel, sen√£o usar nome com fallback
          KEYVAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          if [[ -n "$KEYVAULT_ENDPOINT" ]]; then
            KEYVAULT_NAME=$(echo "$KEYVAULT_ENDPOINT" | sed 's|https://\(.*\)\.vault\.azure\.net/.*|\1|')
            echo "üìç Usando Key Vault do endpoint: $KEYVAULT_NAME"
          else
            KEYVAULT_NAME="${{ secrets.AZURE_KEYVAULT_NAME || 'kv-conexao-de-sorte' }}"
            echo "üìç Usando Key Vault do nome: $KEYVAULT_NAME"
          fi

          # Obter secrets do RabbitMQ
          secrets_list="conexao-de-sorte-rabbitmq-username,conexao-de-sorte-rabbitmq-password"

          IFS=',' read -ra SECRETS_ARRAY <<< "$secrets_list"
          for secret_name in "${SECRETS_ARRAY[@]}"; do
            echo "üîç Obtendo segredo: $secret_name"
            secret_value=$(az keyvault secret show --vault-name "$KEYVAULT_NAME" --name "$secret_name" --query 'value' -o tsv 2>/dev/null || echo "")

            if [[ -n "$secret_value" ]]; then
              echo "‚úÖ Segredo obtido: $secret_name"
              echo "$secret_name=$secret_value" >> $GITHUB_ENV
            else
              echo "‚ùå Erro ao obter segredo: $secret_name"
              exit 1
            fi
          done

      - name: Preparar secrets do RabbitMQ
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        run: |
          set -Eeuo pipefail
          username="${conexao-de-sorte-rabbitmq-username}"
          password="${conexao-de-sorte-rabbitmq-password}"
          if [[ -z "$username" || -z "$password" ]]; then
            echo '‚ùå Segredos do RabbitMQ n√£o retornados pelo Key Vault'
            exit 1
          fi
          echo "::add-mask::$username"
          echo "::add-mask::$password"
          if [[ ${#password} -lt 12 ]]; then
            echo '‚ùå Password muito curto (m√≠nimo 12 caracteres)'
            exit 1
          fi
          username_file="$RUNNER_TEMP/rabbitmq_username"
          password_file="$RUNNER_TEMP/rabbitmq_password"
          printf '%s\n' "$username" > "$username_file"
          printf '%s\n' "$password" > "$password_file"
          chmod 600 "$username_file" "$password_file"
          printf 'RABBITMQ_USERNAME_FILE=%s\n' "$username_file" >> "$GITHUB_ENV"
          printf 'RABBITMQ_PASSWORD_FILE=%s\n' "$password_file" >> "$GITHUB_ENV"

      - name: Criar Docker secrets
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        run: |
          set -Eeuo pipefail
          declare -A secrets=(
            [RABBITMQ_USERNAME]="$RABBITMQ_USERNAME_FILE"
            [RABBITMQ_PASSWORD]="$RABBITMQ_PASSWORD_FILE"
          )
          for secret_name in "${!secrets[@]}"; do
            file="${secrets[$secret_name]}"
            if [[ ! -f "$file" ]]; then
              echo "‚ùå Arquivo do secret $secret_name n√£o encontrado ($file)"
              exit 1
            fi
            if docker secret ls --format "{{.Name}}" | grep -q "^${secret_name}$"; then
              echo "üîÑ Atualizando secret ${secret_name}"
              docker secret rm "$secret_name" || true
              sleep 2
            else
              echo "üÜï Criando secret ${secret_name}"
            fi
            docker secret create "$secret_name" "$file"
          done
          echo "‚úÖ Secrets do RabbitMQ prontos para o deploy"

      - name: üîß Garantir recursos Docker
        run: |
          set -Eeuo pipefail
          if ! docker volume ls | grep -q '\brabbitmq_data$'; then
            echo 'üìÅ Criando volume rabbitmq_data'
            docker volume create rabbitmq_data
          else
            echo '‚úÖ Volume rabbitmq_data j√° existe'
          fi
          echo 'üõ†Ô∏è Ajustando permiss√µes do volume para UID 999'
          docker run --rm -v rabbitmq_data:/var/lib/rabbitmq alpine:3.20 \
            sh -c 'chown -R 999:999 /var/lib/rabbitmq' || echo '‚ÑπÔ∏è Ajuste de permiss√µes n√£o aplicado (verificar manualmente)'
          if ! docker network ls | grep -q 'conexao-network-swarm'; then
            echo 'üåê Criando rede conexao-network-swarm'
            docker network create --driver overlay conexao-network-swarm
          else
            echo '‚úÖ Rede conexao-network-swarm j√° existe'
          fi

      - name: üöÄ Deploy RabbitMQ Stack (Swarm-Only)
        env:
          STACK_NAME: conexao-rabbitmq
          COMPOSE_FILE: docker-compose.yml
        run: |
          echo "üöÄ Iniciando deploy do RabbitMQ com Docker Swarm..."

          # Remover stack existente se houver
          if docker stack ls | grep -q "$STACK_NAME"; then
            echo "üîÑ Removendo stack existente '$STACK_NAME'..."
            docker stack rm "$STACK_NAME"
            sleep 10
          fi

          # Deploy da nova stack
          echo "üèóÔ∏è Executando deploy da stack '$STACK_NAME'..."
          docker stack deploy -c "$COMPOSE_FILE" "$STACK_NAME"

          echo "‚è∞ Aguardando estabiliza√ß√£o dos servi√ßos RabbitMQ..."
          sleep 35

      - name: Healthcheck RabbitMQ (Multi-m√©todo)
        env:
          STACK_NAME: conexao-rabbitmq
        run: |
          echo "üîç Validando sa√∫de do RabbitMQ com health checks robustos..."

          # Aguardar at√© 3 minutos para RabbitMQ ficar dispon√≠vel
          timeout=180
          elapsed=0
          health_passed=false

          while [ $elapsed -lt $timeout ] && [ "$health_passed" = false ]; do
            RABBITMQ_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_rabbitmq" | head -1)

            if [ -n "$RABBITMQ_CONTAINER" ]; then
              echo "üîç Testando health check do RabbitMQ... ($elapsed/$timeout segundos)"

              # M√©todo 1: Comando nativo rabbitmq-diagnostics
              if docker exec "$RABBITMQ_CONTAINER" rabbitmq-diagnostics ping 2>/dev/null; then
                echo "‚úÖ RabbitMQ health check passed (native command)"
                health_passed=true
                break
              fi

              # M√©todo 2: Verificar logs de inicializa√ß√£o
              if docker logs "$RABBITMQ_CONTAINER" 2>/dev/null | grep -q "completed with.*plugins\\|Server startup complete\\|started TCP listener"; then
                echo "‚úÖ RabbitMQ health check passed (logs validation)"
                health_passed=true
                break
              fi

              # M√©todo 3: Verificar se portas est√£o ativas
              if docker exec "$RABBITMQ_CONTAINER" ss -tuln 2>/dev/null | grep -q ":5673 \\|:15673 "; then
                echo "‚úÖ RabbitMQ health check passed (ports active)"
                health_passed=true
                break
              fi

              echo "‚è≥ RabbitMQ ainda n√£o est√° pronto... ($elapsed/$timeout segundos)"
            else
              echo "‚è≥ Container RabbitMQ ainda n√£o encontrado... ($elapsed/$timeout segundos)"
            fi

            sleep 10
            elapsed=$((elapsed + 10))
          done

          if [ "$health_passed" = false ]; then
            echo "‚ö†Ô∏è RabbitMQ health check n√£o passou em $timeout segundos"
            echo "üîç Verificando logs finais do RabbitMQ..."
            if [ -n "$RABBITMQ_CONTAINER" ]; then
              echo "--- √öltimos 30 logs do RabbitMQ ---"
              docker logs "$RABBITMQ_CONTAINER" --tail 30 2>/dev/null || true
              echo "--- Fim dos logs ---"
            fi
            echo "üí° Nota: RabbitMQ pode estar funcionando mesmo com health check parcial"
            echo "üí° Verifique os logs acima para diagn√≥stico"
            exit 1
          else
            echo "‚úÖ RabbitMQ health check conclu√≠do com sucesso!"
          fi

      - name: Connectivity Validation
        env:
          STACK_NAME: conexao-rabbitmq
        run: |
          echo "üîó Validando conectividade do RabbitMQ..."

          # Verificar se o servi√ßo est√° listado no Swarm
          if docker service ls | grep -q "${STACK_NAME}_rabbitmq"; then
            echo "‚úÖ Servi√ßo RabbitMQ encontrado no Swarm"
          else
            echo "‚ùå Servi√ßo RabbitMQ n√£o encontrado no Swarm"
            exit 1
          fi

          # Verificar se est√° na rede correta
          if docker network inspect conexao-network-swarm | grep -q rabbitmq; then
            echo "‚úÖ RabbitMQ conectado √† rede overlay"
          else
            echo "‚ö†Ô∏è RabbitMQ pode n√£o estar na rede overlay correta"
          fi

          # Verificar endpoints espec√≠ficos
          RABBITMQ_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_rabbitmq" | head -1)
          if [ -n "$RABBITMQ_CONTAINER" ]; then
            # Testar Management UI
            if docker exec "$RABBITMQ_CONTAINER" ss -tuln 2>/dev/null | grep -q ":15673 "; then
              echo "‚úÖ RabbitMQ Management UI ativo (porta 15673)"
            else
              echo "‚ÑπÔ∏è RabbitMQ Management UI n√£o detectado"
            fi

            # Testar AMQP port
            if docker exec "$RABBITMQ_CONTAINER" ss -tuln 2>/dev/null | grep -q ":5673 "; then
              echo "‚úÖ RabbitMQ AMQP port ativo (porta 5673)"
            else
              echo "‚ÑπÔ∏è RabbitMQ AMQP port n√£o detectado"
            fi
          fi

          echo "üìä Status final dos servi√ßos:"
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

      - name: Traefik Health Monitor Validation
        run: |
          set -euo pipefail
          HEALTH_MONITOR_URL="https://traefik.conexaodesorte.com.br/health/service/rabbitmq"
          TIMEOUT_TOTAL=300
          INTERVAL=10
          elapsed=0
          last_response=""
          status=""

          while [ $elapsed -lt $TIMEOUT_TOTAL ]; do
            echo "üîé Consultando Traefik (${elapsed}/${TIMEOUT_TOTAL}s)..."
            response=$(curl -sf --max-time 10 "$HEALTH_MONITOR_URL" 2>/dev/null || true)
            last_response="$response"

            if [[ -n "$response" ]]; then
              status=$(echo "$response" | python3 -c "import json,sys;data=json.load(sys.stdin);print(data.get('status',''))" 2>/dev/null || true)
              status=${status//$'\n'/}
              echo "üìä Status reportado: ${status:-indefinido}"

              if [[ "$status" == "healthy" ]]; then
                echo "‚úÖ Traefik confirmou RabbitMQ como healthy"
                exit 0
              fi
            else
              echo "‚ö†Ô∏è Traefik sem resposta nesta tentativa"
            fi

            sleep "$INTERVAL"
            elapsed=$((elapsed + INTERVAL))
          done

          echo "‚ùå Traefik nao confirmou RabbitMQ como healthy apos ${TIMEOUT_TOTAL}s"
          echo "üìù Ultima resposta recebida: ${last_response:-<sem resposta>}"
          exit 1
