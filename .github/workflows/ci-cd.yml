name: ğŸ° RabbitMQ Infrastructure - CI/CD Pipeline

on:
  push:
    branches: [ main ]
    paths: ['docker-compose.yml', 'scripts/**', '.github/workflows/**', 'README.md']
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Destino do deploy'
        required: false
        default: 'production'
        type: choice
        options: [production, staging]

# ----------------------------------------------------------------------
# PARÃ‚METROS GERAIS
# ----------------------------------------------------------------------

env:
  SERVICE_NAME: conexao-de-sorte-rabbitmq-infraestrutura
  TZ: America/Sao_Paulo
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}

# ConfiguraÃ§Ã£o de permissÃµes para GitHub OIDC
permissions:
  id-token: write
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash -euo pipefail {0}

# ----------------------------------------------------------------------
# JOB 1 â–¸ VALIDAÃ‡ÃƒO DO AMBIENTE
# ----------------------------------------------------------------------

jobs:
  validate-compose:
    runs-on: [self-hosted, Linux, X64, srv649924, conexao, conexao-de-sorte-rabbitmq-infraestrutura]
    name: ğŸ” Validate Docker Compose
    timeout-minutes: 10
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”§ Set Dummy Environment Variables for Validation
        run: |
          echo "RABBITMQ_USERNAME=dummy_user_for_validation" >> $GITHUB_ENV
          echo "RABBITMQ_PASSWORD=dummy_password_for_validation" >> $GITHUB_ENV
          echo "âœ… Dummy environment variables (RABBITMQ_USERNAME, RABBITMQ_PASSWORD) set for validation"

      - name: ğŸ” Validate docker-compose files
        timeout-minutes: 2
        run: |
          # Validar sintaxe do docker-compose.yml principal (produÃ§Ã£o)
          docker compose -f docker-compose.yml config -q
          echo "âœ… Docker Compose syntax is valid"

      - name: ğŸ§® Render Docker Stack configuration
        timeout-minutes: 2
        run: |
          # Garantir que o arquivo Ã© vÃ¡lido para uso com docker stack deploy
          docker stack config -c ./docker-compose.yml > /tmp/docker-stack-rendered.yml
          echo "âœ… Docker Stack configuration rendered successfully"

      - name: ğŸ§ª Test Services Definition
        timeout-minutes: 3
        run: |
          # Verificar se todos os serviÃ§os essenciais estÃ£o definidos
          echo "ğŸ” Debug: Listing all available services:"
          all_services=$(docker compose -f docker-compose.yml config --services | sort)
          echo "$all_services"

          echo ""
          echo "ğŸ§ª Testing each service individually:"
          services=("rabbitmq")

          missing=()
          for service in "${services[@]}"; do
            if echo "$all_services" | grep -Fxq "$service"; then
              echo "âœ… Service '$service' found in main docker-compose.yml"
            else
              missing+=("$service")
            fi
          done

          [ ${#missing[@]} -eq 0 ] || { echo "âŒ Missing services: ${missing[*]}"; exit 1; }

      - name: ğŸŒ Validate Network Configuration
        timeout-minutes: 2
        run: |
          # Verificar se a rede externa estÃ¡ configurada
          if docker network inspect conexao-network-swarm >/dev/null 2>&1; then
            echo "âœ… Network 'conexao-network-swarm' configured"
          else
            echo "âŒ Network 'conexao-network-swarm' missing"
            exit 1
          fi

      - name: ğŸ’¾ Validate Volumes Configuration
        timeout-minutes: 2
        run: |
          volumes=("rabbitmq_data")
          for volume in "${volumes[@]}"; do
            if docker volume inspect "$volume" >/dev/null 2>&1; then
              echo "âœ… Volume '$volume' configured"
            else
              echo "âŒ Volume '$volume' missing"
              exit 1
            fi
          done

# ----------------------------------------------------------------------
# JOB 2 â–¸ SECURITY SCAN
# ----------------------------------------------------------------------

  security-scan:
    runs-on: [self-hosted, Linux, X64, srv649924, conexao, conexao-de-sorte-rabbitmq-infraestrutura]
    name: ğŸ” Security Scan
    timeout-minutes: 15
    needs: [validate-compose]
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ” Check for hardcoded secrets
        timeout-minutes: 3
        run: |
          if [ -f "docker-compose.yml" ]; then
            if grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "file:" | grep -v "external:" | grep -E "password:[[:space:]]*[^[:space:]\$]"; then
              echo "âŒ Found hardcoded passwords in compose files"
              echo "Lines with potential hardcoded passwords:"
              grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "file:" | grep -v "external:" | grep -E "password:[[:space:]]*[^[:space:]\$]" || true
              exit 1
            else
              echo "âœ… No hardcoded passwords found"
            fi
          else
            echo "âŒ docker-compose.yml nÃ£o encontrado"
            exit 1
          fi

      - name: ğŸ” Check environment variables
        timeout-minutes: 2
        run: |
          if [ -f "docker-compose.yml" ]; then
            required_envs=("RABBITMQ_USERNAME" "RABBITMQ_PASSWORD")
            for env_var in "${required_envs[@]}"; do
              if ! grep -q "$env_var" docker-compose.yml; then
                echo "âŒ Environment variable $env_var not found in docker-compose.yml"
                exit 1
              else
                echo "âœ… Environment variable $env_var found"
              fi
            done
          else
            echo "âŒ docker-compose.yml nÃ£o encontrado"
            exit 1
          fi

      - name: ğŸ” Scan image versions for vulnerabilities
        timeout-minutes: 10
        run: |
          if [ -f "docker-compose.yml" ]; then
            # Verificar se imagens usam tags especÃ­ficas (evitar latest)
            if grep -q ":latest" docker-compose.yml; then
              echo "âŒ Uso de tags 'latest' detectado - nÃ£o recomendado para produÃ§Ã£o"
              exit 1
            else
              echo "âœ… Todas as imagens usam tags especÃ­ficas"
            fi
          else
            echo "âŒ docker-compose.yml nÃ£o encontrado"
            exit 1
          fi

# ----------------------------------------------------------------------
# JOB 3 â–¸ DEPLOY PARA PRODUÃ‡ÃƒO
# ----------------------------------------------------------------------

  deploy-production:
    if: github.ref == 'refs/heads/main'
    runs-on: [self-hosted, Linux, X64, srv649924, conexao, conexao-de-sorte-rabbitmq-infraestrutura]
    name: ğŸš€ Deploy to Production
    timeout-minutes: 30
    needs: [validate-compose, security-scan]
    permissions:
      id-token: write
      contents: read
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ” Validar e configurar secrets Azure OIDC infraestrutura
        shell: bash
        run: |
          echo "ğŸ” Validando secrets OIDC para infraestrutura RabbitMQ..."
          echo "ğŸ“ RepositÃ³rio: ${{ github.repository }}"

          # Verificar se secrets estÃ£o configurados neste repositÃ³rio especÃ­fico
          MISSING_SECRETS=""
          if [ -z "${{ secrets.AZURE_CLIENT_ID }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_CLIENT_ID"
          fi
          if [ -z "${{ secrets.AZURE_TENANT_ID }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_TENANT_ID"
          fi
          if [ -z "${{ secrets.AZURE_SUBSCRIPTION_ID }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_SUBSCRIPTION_ID"
          fi
          if [ -z "${{ secrets.AZURE_KEYVAULT_NAME }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_KEYVAULT_NAME"
          fi

          if [ -n "$MISSING_SECRETS" ]; then
            echo "âŒ Secrets ausentes no repositÃ³rio ${{ github.repository }}:$MISSING_SECRETS"
            echo ""
            echo "ğŸ”§ SOLUÃ‡ÃƒO NECESSÃRIA:"
            echo "1. Acessar: https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "2. Adicionar os seguintes Repository secrets:"
            echo "   - AZURE_CLIENT_ID: [Service Principal Client ID]"
            echo "   - AZURE_TENANT_ID: [Azure Tenant ID]"
            echo "   - AZURE_SUBSCRIPTION_ID: [Azure Subscription ID]"
            echo "   - AZURE_KEYVAULT_NAME: [Nome do Key Vault]"
            echo ""
            echo "ğŸ’¡ Os values devem ser copiados do repositÃ³rio principal ou do Azure Portal"
            echo ""
            echo "âš ï¸  PULANDO DEPLOY - Secrets de infraestrutura nÃ£o configurados"
            exit 0  # Exit com sucesso para nÃ£o falhar o pipeline, mas pular deploy
          fi

          echo "âœ… Secrets infraestrutura OIDC validados para ${{ github.repository }}"

      - name: ğŸ”‘ Azure Login (OIDC)
        uses: azure/login@v2
        timeout-minutes: 5
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: false

      - name: ğŸ” Verificar conectividade Azure infraestrutura
        shell: bash
        run: |
          echo "ğŸ” Verificando conectividade Azure infraestrutura RabbitMQ..."

          if ACCOUNT_INFO=$(az account show --query "{name: name, id: id}" -o json 2>/dev/null); then
            echo "âœ… Login Azure infraestrutura confirmado:"
            echo "$ACCOUNT_INFO" | jq -r '"  Subscription: \(.name) (\(.id))"'
          else
            echo "âŒ Falha login Azure infraestrutura"
            exit 1
          fi

      - name: ğŸ§¹ Smart Cleanup - Remove existing RabbitMQ stack
        timeout-minutes: 10
        run: |
          set -euo pipefail
          STACK_NAME="conexao-de-sorte-rabbitmq-production"

          echo "ğŸ§¹ Removendo stack RabbitMQ existente para deploy limpo..."

          if docker stack ls | grep -q "$STACK_NAME"; then
            echo "ğŸ”„ Removendo stack '$STACK_NAME'..."
            docker stack rm "$STACK_NAME"

            echo "â° Aguardando remoÃ§Ã£o completa da stack..."
            timeout=120
            elapsed=0
            while docker stack ls | grep -q "$STACK_NAME" && [ $elapsed -lt $timeout ]; do
              sleep 5
              elapsed=$((elapsed + 5))
              echo "â³ Aguardando... ($elapsed/$timeout segundos)"
            done

            if docker stack ls | grep -q "$STACK_NAME"; then
              echo "âŒ Falha ao remover a stack '$STACK_NAME'. Abortando pipeline."
              exit 1
            fi
            echo "âœ… Stack '$STACK_NAME' removida."
          else
            echo "â„¹ï¸ Stack '$STACK_NAME' nÃ£o encontrada (primeira execuÃ§Ã£o ou jÃ¡ removida)"
          fi

      - name: ğŸ” Sync Azure KeyVault Secrets to Docker Swarm
        timeout-minutes: 5
        run: |
          set -euo pipefail
          STACK_NAME="conexao-de-sorte-rabbitmq-production"

          echo "ğŸ” Verificando se a stack '$STACK_NAME' foi removida antes da sincronizaÃ§Ã£o..."
          if docker stack ls | grep -q "$STACK_NAME"; then
            echo "âŒ Stack '$STACK_NAME' ainda estÃ¡ presente. Abortando sincronizaÃ§Ã£o de secrets."
            exit 1
          fi
          echo "âœ… Stack '$STACK_NAME' removida. Prosseguindo com sincronizaÃ§Ã£o de secrets."

          echo "ğŸ” Sincronizando secrets do Azure Key Vault para Docker Swarm..."
          echo "ğŸª Key Vault: ${{ env.AZURE_KEYVAULT_NAME }}"

          # Executar script de sincronizaÃ§Ã£o
          chmod +x .github/workflows/scripts/sync-azure-keyvault-secrets.sh
          .github/workflows/scripts/sync-azure-keyvault-secrets.sh "${{ env.AZURE_KEYVAULT_NAME }}" "rabbitmq-infraestrutura" || {
            echo "âŒ Timeout ou falha na sincronizaÃ§Ã£o de secrets apÃ³s 5 minutos"
            echo "ğŸ” Verificando estado atual dos secrets..."
            docker secret ls --format "table {{.Name}}\t{{.CreatedAt}}" | head -10 || true
            exit 1
          }

      - name: ğŸ” Validate Critical Secrets Created
        timeout-minutes: 2
        run: |
          # Verificar se os secrets crÃ­ticos foram criados
          critical_secrets=("RABBITMQ_USERNAME" "RABBITMQ_PASSWORD")

          echo "ğŸ” Verificando se secrets crÃ­ticos estÃ£o disponÃ­veis no Docker Swarm..."

          for secret in "${critical_secrets[@]}"; do
            if docker secret inspect "$secret" >/dev/null 2>&1; then
              echo "âœ… $secret: READY"
            else
              echo "âŒ $secret: MISSING - ABORTING DEPLOY"
              exit 1
            fi
          done

          echo "âœ… Todos os secrets crÃ­ticos estÃ£o disponÃ­veis para RabbitMQ - prosseguindo com deploy"

      - name: ğŸš€ Deploy RabbitMQ Stack to Production
        timeout-minutes: 15
        run: |
          set -euo pipefail
          STACK_NAME="conexao-de-sorte-rabbitmq-production"

          echo "ğŸš€ Iniciando deploy da stack RabbitMQ para produÃ§Ã£o..."

          # Garantir que a stack foi removida antes do deploy
          if docker stack ls | grep -q "$STACK_NAME"; then
            echo "âŒ Stack '$STACK_NAME' ainda estÃ¡ presente apÃ³s etapa de remoÃ§Ã£o."
            echo "ğŸ”§ Verifique a etapa 'ğŸ§¹ Remove existing RabbitMQ stack'."
            exit 1
          fi
          echo "âœ… ConfirmaÃ§Ã£o: stack '$STACK_NAME' removida. Prosseguindo com deploy em produÃ§Ã£o..."

          # Verificar se o arquivo de configuraÃ§Ã£o existe
          if [ ! -f "docker-compose.yml" ]; then
            echo "âŒ ERRO na configuraÃ§Ã£o do docker-compose.yml para RabbitMQ PRODUÃ‡ÃƒO"
            echo "ğŸ” Listando secrets disponÃ­veis:"
            docker secret ls --format "table {{.Name}}\t{{.CreatedAt}}"
            exit 1
          fi

          # Deploy da stack utilizando docker-compose.yml (PRODUÃ‡ÃƒO)
          echo "ğŸ—ï¸ Executando deploy da stack '$STACK_NAME'..."
          docker stack deploy -c docker-compose.yml "$STACK_NAME"

          echo "â° Aguardando estabilizaÃ§Ã£o dos serviÃ§os RabbitMQ..."
          sleep 30

          echo "ğŸ” Verificando status dos serviÃ§os RabbitMQ..."
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

      - name: ğŸ§ª Health Check Validation RabbitMQ
        timeout-minutes: 10
        run: |
          set -euo pipefail
          STACK_NAME="conexao-de-sorte-rabbitmq-production"

          echo "ğŸ” Validating RabbitMQ service health..."

          # RabbitMQ health check
          RABBITMQ_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_rabbitmq" | head -1)
          if [ -n "$RABBITMQ_CONTAINER" ]; then
            echo "ğŸ” Testing RabbitMQ connectivity..."

            # Aguardar atÃ© 5 minutos para RabbitMQ ficar disponÃ­vel
            timeout=300
            elapsed=0
            while [ $elapsed -lt $timeout ]; do
              if docker exec "$RABBITMQ_CONTAINER" rabbitmq-diagnostics ping 2>/dev/null; then
                echo "âœ… RabbitMQ health check passed em PRODUÃ‡ÃƒO"
                break
              else
                echo "â³ RabbitMQ ainda nÃ£o estÃ¡ pronto... ($elapsed/$timeout segundos)"
                sleep 10
                elapsed=$((elapsed + 10))
              fi
            done

            if [ $elapsed -ge $timeout ]; then
              echo "âŒ RabbitMQ health check failed em PRODUÃ‡ÃƒO - timeout apÃ³s $timeout segundos"
              echo "ğŸ” Verificando logs do container RabbitMQ..."
              docker logs "$RABBITMQ_CONTAINER" --tail 50 2>/dev/null || true
              exit 1
            fi
          else
            echo "âŒ Container RabbitMQ nÃ£o encontrado no Swarm PRODUÃ‡ÃƒO"
            exit 1
          fi

      - name: ğŸ“Š Service Status Report RabbitMQ
        timeout-minutes: 2
        run: |
          echo "ğŸ“Š Final RabbitMQ service status report:"
          docker service ls --filter name="conexao-de-sorte-rabbitmq-production_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

          echo -e "\nğŸ’¾ Volume usage:"
          docker volume ls | grep -E "(rabbitmq)" || echo "No RabbitMQ volumes found"

          echo -e "\nğŸŒ Network configuration:"
          docker network inspect conexao-network-swarm | jq '.[] | {Name: .Name, Driver: .Driver, Subnet: .IPAM.Config[0].Subnet}' || echo "âš ï¸  Rede conexao-network-swarm nÃ£o encontrada"